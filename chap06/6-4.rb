# int型の配列の角要素に1〜10の乱数を代入し、角要素の値を縦向きの棒グラフ（記号文字*の並び）で表示するプログラムを作成せよ。要素数はキーボードから読み込むこと。
# 最終段には、インデックスを10で割った剰余を表示すること。

# 実行例
# 要素数: 12
#               *         
# *             *     *   
# *             *     *   
# *             *     *   
# *             *     *   
# *             *     *   
# *         * * * * * *   
# *       * * * * * * * * 
# *   * * * * * * * * * * 
# * * * * * * * * * * * * 
# ------------------------
# 0 1 2 3 4 5 6 7 8 9 0 1 


print "要素数: "
limit = gets.chomp.to_i

a = []
# 空の配列aに1〜10の乱数をlimit個、格納。
(1..limit).each do |n|
    a << rand(1..10)
end

# この部分、めちゃ苦戦した！
# 今回は横の棒グラフではなく、縦の棒グラフなので、これまでみたいに単純な繰り返しではなく、二重の繰り返し処理が必要。左上を原点として(1,1)から(limit, 10)の範囲にスペースか＊を埋めていく。
# 繰り返しの大きな枠はグラフの上から1段目から10段ある、縦方向の段の繰り返し処理 / 小さい枠（入れ子）の繰り返し処理は横方向の行の繰り返し処理
# 段を1段1段切り取って、考える。配列aの要素を取り出して、グラフの上からみた1段目（つまり、棒グラフのてっぺん（最大値10））が*になるのは配列の要素が10のときだけ。
# つまり、配列の各要素が10以上なら「＊ 」を、そうでなければ「  」を出力するようにする。この時小さい枠の繰り返し処理は横方向の繰り返し処理なので、繰り返し処理の結果は横方向に続けて出力したいのでprintで出力。
# 1行分の横方向の繰り返し処理が終わったら、次の段の出力を始めるため、puts ''で改行文字を入れてあげる。
# 以上を10段分繰り返すと、配列の各要素の値に対応した縦方向の棒グラフが完成する。
(1..10).to_a.each do |i|
    (1..limit).each do |j|
        if a[j-1].to_i >= (10 - i + 1)
            print '* '
        else
            print '  '
        end
    end
    puts ''
end

# 線を引く
puts "#{'-' * limit * 2}"

# 各棒グラフの下にはインデックスを10で割った剰余を表示することになっているので。
(1..limit).each do |k|
    print "#{(k-1) % 10} "
end
