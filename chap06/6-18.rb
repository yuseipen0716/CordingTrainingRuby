# 4行3列の行列と3行4列の積を求めるプログラムを作成せよ。角要素の値はキーボードから読み込むこと。

# 実行例
# 行列aの要素の値を入力せよ。
# a[0][0] : 1
# a[0][1] : 2
# a[0][2] : 3
# a[1][0] : 2
# a[1][1] : 3
# a[1][2] : 1
# a[2][0] : 3
# a[2][1] : 1
# a[2][2] : 2
# a[3][0] : 2
# a[3][1] : 1
# a[3][2] : 3
# 行列bの要素の値を入力せよ。
# b[0][0] : 4
# b[0][1] : 3
# b[0][2] : 2
# b[0][3] : 1
# b[1][0] : 3
# b[1][1] : 2
# b[1][2] : 1
# b[1][3] : 4
# b[2][0] : 2
# b[2][1] : 1
# b[2][2] : 4
# b[2][3] : 3

# 行列aとbの積
#     16  10  16  18
#     19  13  11  17
#     19  13  15  13
#     17  11  17  15

# Array.new(4,Array.new(3))というようにはしないように。二次元目の配列が同一オブジェクトとしてみなされてしまうみたい。ブロックを渡して都度評価
a = Array.new(4){Array.new(3)}
b = Array.new(3){Array.new(4)}
c = Array.new(4){Array.new(4)}

puts '行列aの要素の値を入力せよ。'
# 4行3列の行列a
(0..3).each do |i|
    (0..2).each do |j|
        print "a[#{i}][#{j}] : "
        # a[i][j] << gets.chomp.to_iとしていたせいでエラーが出ていた a[i][j]に代入という考え方。
        a[i][j] = gets.chomp.to_i 
    end    
end

# puts "#{a}"

puts '行列bの要素の値を入力せよ。'
# 3行4列の行列b
(0..2).each do |i|
    (0..3).each do |j|
        print "b[#{i}][#{j}] : "
        b[i][j] = gets.chomp.to_i 
    end    
end

# puts "#{b}"

# 行列aとbの積
(0..3).each do |i|
    (0..3).each do |j|
        c[i][j] = (a[i][0] * b[0][j]) + (a[i][1] * b[1][j]) + (a[i][2] * b[2][j])
    end
end

puts '行列aとbの積'

(0..3).each do |l|
    print "\n" if l > 0
    (0..3).each do |m|
        print "  #{c[l][m]}  "
    end
end


